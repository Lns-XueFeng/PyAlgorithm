"""
author: Lns-XueFeng
CreateTime: 2023.03.13
"""


"""递归三定律
1.递归算法必须有一个基本的结束条件（最小规模问题直接解决）
2.递归算法必须能够改变自身的状态向基本条件演进（减小问题规模但仍可用相同解法）
3.递归算法必须调用自身（解决减小了规模的相同问题）

用递归解决问题的时候需铭记在心三定律，以及记住递归与栈的联系！
"""


# 数列求和
def sum_(li):
    if len(li) == 1:   # 递归退出条件
        return li[0]   # 基本问题
    return li[0] + sum_(li[1:])   # 通过调用自身解决规模更小的问题


sum_([1, 2, 3, 4, 5])   # result->15


"""
”数列求和“即为使用递归的一个例子
通过不断减小问题的规模，并且均可通过调用自身解决
直至最简单的情况，结束自身调用开始返回

我们都知道，函数内的变量存在栈中
因此你可以想象，当第一次进入sum_函数时，相关变量被推入栈中
然后递归调用自身，第二次又进入了sum_函数，相关变量又被推入栈中（和上次的变量的值不一样了）
就这样一直调用，一直被推入栈，直至遇到递归推出条件时，栈中的变量终于可以开始往外弹...

将每一次压入栈中的变量情况画在纸上，就会变得非常易于理解，因为最终从栈顶开始弹出的就是最简单的求解情况
最简单的知道了，次简单的弹出基于最简单的也就可以轻松解决，依此类推最终解决复杂问题

除了自己画栈图，还可以debug来看每一次递归的变量情况
"""


"""递归适用于哪些问题？
递归算法一般用于解决三类问题：
1问题解的定义是按递归定义的（代表有阶乘、斐波那契数列）
  这种场景只有逐渐沿着变化趋势，线性的找到可以计算出直接结果的值才能逆向返回，最终得到目标结果
  它的结束策略通常是在结束条件中使用大于、小于等判断条件；将结束条件由等于指定值改为达到指定区间

2问题解法由回溯算法实现（如数字排列组合问题）

3数据的结构形式是按递归定义的（树的遍历，图的搜索、嵌套列表）


它们都具有的特征是：
1.解决问题时，可以把一个问题转化为一个新的问题，而这个新的问题的解决方法仍与原问题的解法相同，
只是所处理的对象规模有所不同，这些被处理的对象之间是有规律的递增或递减
2.可以通过转化过程使问题得到解决；
3.必定要有一个明确的结束递归的条件，否则递归将会无止境地进行下去
"""
